#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass report
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
Introduction
\end_layout

\begin_layout Standard
This work is the final thesis for the programme European Computer Science
 Studies at Hochschule Osnabrück created during exchange studies at the
 Mid Sweden University in Sundsvall.
\end_layout

\begin_layout Section
Background
\end_layout

\begin_layout Standard
Applications that can change their behaviour based on the context of the
 users are called context-aware applications.
 By the introduction of smart mobile phones that carry a multitude of sensors
 and actors, these applications have had a very large market penetration.
 The Mid Sweden University has so far produced initial components for the
 accumulation of context information from sensors and wireless sensor networks
 from numerous sources, e.g.
 sensors attached to home networks or mobile phones.
 This project comes along with the development of a next generation Internet-of-
Things (IoT) architecture and their supporting protocols.
 The IoT is defined as applications that use information from sensors and
 actors to provide personalized, automatized or intelligent behaviours to
 the users.
\end_layout

\begin_layout Section
Overall aim and problem motivation
\end_layout

\begin_layout Standard
To initiate a connection between two MediaSense instances (contexts) a lookup-se
rvice is needed.
 To handle the communication between two contexts a transport protocol is
 necessary.
 The present lookup-service, that has been implemented by the Mid Sweden
 University so far, is based on a client-server architecture.
 The well-known network protocols Transmission Control Protocol (TCP) or
 User Datagram Protocol (UDP) can be used for data transmission.
 Since its beginning it is a requirement to the MediaSense platform to not
 have a single point of failure.
 The client-server architecture does not fulfil that need.
 For this reason a distributed lookup-service will be developed during this
 thesis work.
 The data transmission of the MediaSense platform has to be reliable and
 packet oriented.
 Neither TCP nor UDP fulfil both requirements at the same time.
 So the need for a self-made communication protocol arises.
 
\end_layout

\begin_layout Section
Detailed problem statement
\end_layout

\begin_layout Enumerate
Develop a simulation environment, using the same Application Programming
 Interface (API) as MediaSense, that allows the parallel running of multiple
 DHT clients
\end_layout

\begin_layout Enumerate
Implement a circular Distributed Hash Table (DHT) based on Chord running
 inside the simulation environment that enables register and resolve operations
 executed in 
\begin_inset Formula $O(log(n))$
\end_inset

 time
\end_layout

\begin_layout Enumerate
Evaluate the performance of the DHT in terms of self healing capability
 and network usage
\end_layout

\begin_layout Enumerate
Transfer the DHT solution into the MediaSense platform
\end_layout

\begin_layout Enumerate
Develop a simulation environment, using the same API as MediaSense, able
 to host two clients communicating over an exchangeable protocol
\end_layout

\begin_layout Enumerate
Develop a reliable packet-based communication protocol (RUDP) based on Berkely
 sockets (BSD sockets)
\end_layout

\begin_layout Enumerate
Compare RUDP to TCP in terms of speed and reliability
\end_layout

\begin_layout Enumerate
Transfer RUDP into MediaSense platform
\end_layout

\begin_layout Section
Scope
\end_layout

\begin_layout Standard
The DHT implementation is focused on handling client joins, leaves and fails
 while remaining the DHT health.
 For the RUDP implementation the thesis focuses on [TODO]
\end_layout

\begin_layout Standard
This thesis does not focus on counteractive measure regarding security issues
 like network attacks and data encryption for both, DHT and RUDP.
\end_layout

\begin_layout Standard
Code must be without external licensing
\end_layout

\begin_layout Section
Outline
\end_layout

\begin_layout Standard
Outline
\end_layout

\begin_layout Subsection
Contributions
\end_layout

\begin_layout Standard
Who did what
\end_layout

\begin_layout Chapter
Theory
\end_layout

\begin_layout Standard
To understand the following chapters in this report, the reader needs to
 have some background knowledge.
 This required knowledge will be given during this chapter.
 
\end_layout

\begin_layout Section
Peer to peer
\end_layout

\begin_layout Standard
The term peer-to-peer (P2P) refers to a computer network in which each participa
nt (peer) acts as client and server for the other participants.
 These architecture allows, to share data over a network without the need
 of a central server.
 
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename clientserver.png

\end_inset


\begin_inset Graphics
	filename peer2peer.png

\end_inset


\end_layout

\begin_layout Standard
P2P is a distributed application architecture that partitions duties and
 responsibilities among all participating peers.
 Each peer, often also referred to as node, has to set aside a portion of
 its resources to make it directly available for the other P2P participants.
 That means, in a P2P architecture each client has the same rights and responsib
ilities.
 In contrary to a P2P network, where each node acts as supplier and consumer,
 stands the client-server-model, where only servers supply and clients consume
 the information.
\end_layout

\begin_layout Subsection
Architecture of peer-to-peer systems
\end_layout

\begin_layout Standard
Generally P2P systems are implemented as an abstract overlay network in
 the application layer, not influencing the physical network layer underneath.
 This overlay performs the indexing and peer discovery and makes the peer-to-pee
r system independent from the network topology
\begin_inset Foot
status open

\begin_layout Plain Layout
http://en.wikipedia.org/wiki/Peer-to-peer
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
P2P networks can further be divided in structured and unstructured systems.
 Structured systems organize their peers and resources with specific algorithms
 typically using distributed-hash-tables (DHT) see XX.
 Whereas unstructured systems do not use any structure in their overlay
 networks.
 
\end_layout

\begin_layout Subsection
Advantages and weaknesses
\end_layout

\begin_layout Standard
In comparison to client-server networks, P2P networks come along with the
 big advantage, that there is no single point of failure (i.e.
 the server in client-server networks).
 In fact P2P networks are getting more stable, the more clients are participatin
g.
\end_layout

\begin_layout Standard
Another advantage of P2P networks is, that all available resources are getting
 more when more clients join the network, while in client-server networks
 the available resources per client are getting less, because all have clients
 have to share the resources from the server.
\end_layout

\begin_layout Standard
On the other side, P2P networks also bring some disadvantages.
 Since each client in the system is responsible to share (publish) some
 of its resources, the whole system is more vulnerable for untrusted or
 unsigned content.
 This would not happen in client-server networks because there is a system
 administrator, who is responsible for publishing the resources.
\end_layout

\begin_layout Section
Hash function
\end_layout

\begin_layout Standard
A hash function maps data with variable size to a hash-value of a fixed
 size by using an algorithm that transforms the data.
 To be usable for a hash table the hash function has to be deterministic,
 which means that it always produces the same output with a given input
 data.
 The function should also produce values that are uniformly spread over
 the possible range of hash values to reduce hash collisions.
 A collision occurs when two different input keys produce the same output.
\end_layout

\begin_layout Standard
An important property of a hash function is the output length, specified
 in bits.
 A function with n bits output length produces hash values in the range
 of 
\begin_inset Formula $0$
\end_inset

 - 
\begin_inset Formula $2^{n-1}$
\end_inset

 and the amount of possible values is 
\begin_inset Formula $2^{n}$
\end_inset

.
\end_layout

\begin_layout Section
Hash table
\end_layout

\begin_layout Standard
A hash table is a data structure that stores key-value pairs.
 The value can be any user-specified value that should be associated with
 the key.
 A hash function is used to transform the key into a hash-value that is
 then used as an index which indicates where the associated user-value is
 stored.
 The use of a hash function introduces the possibility of hash collision,
 different keys forming the same hash-value.
 There are several ways to deal with a collision situation, where the easiest
 way is to deny the colliding key.
\end_layout

\begin_layout Standard
The hash-table used in this project does not use advanced collision handling
 techniques, so they are not described in this document.
\end_layout

\begin_layout Section
Distributed Hash Table
\end_layout

\begin_layout Standard
A distributed hash table is the same as a hash table as described in the
 last paragraph except that the table is distributed among several parties,
 where each party is responsible for a certain amount of the hash space.
 In the sense of P2P, party means one connected client in a distributed
 system.
\end_layout

\begin_layout Standard
To partition the DHT, each node must have a unique identification key from
 the hash space that is either random or derived from unique data.
\end_layout

\begin_layout Standard
Every node of a DHT can store and retrieve values in the DHT and must be
 able to handle requests when the requested key is in the own space of responsib
ility.
 The DHT nodes have to be connected to each other in some way to be able
 to interchange requests.
 There are many different possibilities to split up the hash space in smaller
 parts, as CAN, Tapestry, Pastry, Chord and others.
 This project deals with Chord, which is is described in more detail in
 the next section.
\end_layout

\begin_layout Section
Chord
\end_layout

\begin_layout Standard
The Chord lookup protocol arranges its participating nodes in a circle with
 a maximum number of nodes limited by the amount of possible values of the
 used hash-function.
\end_layout

\begin_layout Standard
Each node is responsible for all hash values between his own key and the
 key of its successor minus one: [id, id_successor)
\end_layout

\begin_layout Standard
As nodes enter, leave or fail, the range of responsibility changes continuously
 and key-value pairs have to be shifted to keep the DHT valid.
\end_layout

\begin_layout Standard
To be able to forward requests, and to know the responsible range of hashes
 each node must at least know its successor node.
 In this case a message between two random nodes will take n/2 steps on
 average, because every node can only forward it to its successor and the
 average traversal distance is half the circle.
 This means that effort to find a position increases linearly with the size
 of the DHT.
 The effort can be expressed as O(n).
 To reduce the effort a finger table is used that is explained in the following
 chapter.
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename Circle.svg
	lyxscale 50
	scale 30
	rotateOrigin center

\end_inset


\end_layout

\begin_layout Subsection
Finger Table
\end_layout

\begin_layout Standard
Each node in a chord DHT contains a list of known nodes of the DHT called
 a finger table to speed up the query process.
 The definition of Chord requires the finger table to point to the succeeding
 nodes of the hash value calculated with the following Formula:
\end_layout

\begin_layout Standard
\begin_inset Formula $n+2^{i+1}\bmod m$
\end_inset

(n+2⁽i⁺¹⁾ mod m) Formula 1: Finger entry
\end_layout

\begin_layout Standard
where n is the key of the node, i is the finger table entry and m is the
 size of the hash-value.
\end_layout

\begin_layout Standard
This means that a node can have up to n finger entries (where m is the maximum
 value of the hash function).
 Using this method the effort to find a position is at maximum O(log2(m))
 because after every step the distance is decreased to the half.#
\end_layout

\end_body
\end_document
